# **Personal Knowledge Engineering (PKE) Systems ... A Manifesto**

*Success is not solely about hard work and the diligency of showing up every day to just bang away fixing the same old shit.*  

Rather, SUCCESS is about having one's eyes on the horizon RATHER THAN THE REAR VIEW MIRROW ... coming up with a credible knowledge-based [rather than tool-based or equipment-based] plan for adaptability in the future ... and that means working harder, in a disciplined manner, up front preparing that plan, developing the tools and systems, like PKE systems, to have FLEXIBLE **SYSTEMS THINKING** in place before the trouble ever shows up ... not just to dig a well before one is thirsty, but to have the knowledge and capacity to engineer well-drilling systems when well-drilling systems are needed ... at its core, PKE is really about intelligently understanding systems and working in the development of knowledge-based systems for future needs, it's NOT personal knowledge management (PKM) -- which is important, but about the management of collections notes, ideas, plans, artifacts, references -- PKE is more forward-thinking, ie thinking about the development of future systems. 

***This means that we need tools and technology for NEW INTELLIGENCE,*** for *intelligence and knowledge that hasn't come into existence yet.*  

Doing this is about systems that have the capacity to gather much more intelligence and knowledge than we currently do. It's also about making the attempts to apply the knowledge that our intelligence gathering ops have obtained more efficient and rapid. PKE is in the system of applying the knowledge and testing assumptions; PKE is about our methodology and thinking that we use to identify causal relationships and validate their veracity in order to utilize shortcuts to overcome challenges and free up time for pursuing ***larger*** goals ... *and, if we love doing this the LARGER goal or reward will be that we get to improve the PKE implementation*! 

This Manifesto attempts to give [an overview](#the-100-day-personal-knowledge-engineering-curriculum-overview) of the primary goals of the 100 modules in our 100-day project to level up our game in PKE systems, as well as outline the core principles of PKE systems and to explain something about what the measures of success will be for this project.  You could say that this 100-module plan is really about **implementing** something akin Marcus du Sautoy's "Thinking Better: The Art of the Shortcut" because a big part of it is a celebration of how mathematical and statistical thinking helps us to solve problems more efficiently in everyday life, in producing anything, in design. 

People might get sidetracked by the fact that du Sautoy's a mathematician, but ***this is most definitely not JUST mathematics***, although mathematics is invaluable for implementing the art of the elegant, stable equilibrium solution. It really about understanding systems in order to find elegant and efficient solutions to complex problems by recognizing patterns and developing general algorithms ... rather than band-aids or cobbled-up, likely to fail fixes. Elegance is about solutions that stay fixed or heal and get better over time.

It is worth emphasizing that elegant thinking "shortcuts" are NOT at all about taking unethical or lazy approaches, but rather about developing a deeper understanding of problems to find more intelligent and clever ways to navigate them. The whole point of developing and using more advanced personal knowledge engineering (PKE) systems is not for PKE itself [although THAT is the goal of the 100 module plan] but to understand systems and genuinely "think better." Getting past the bandaid or likely-to-just-break-down-and-fail-again fix is about adopting not just a mindset but an entire PKE arsenal that allows one to understand, seek out and leverage the more clever solutions, recognizing that efficiency and deeper understanding can lead to more fulfilling and impactful achievements.

## Primary Goals

- The core objective is progressive, to advance beyond the transition from the passive practice of *Personal Knowledge Management (PKM)* and make PKM note-gather more the mere collection of random notes and notetaking apps ... ***TOWARD*** ... a more actively evolving or extensible, disciplined system of AI-assisted ***Personal Knowledge Engineering (PKE)*** ... which presents all kind of opportunities that enhance our capacity to contribute to significant work in extensible open-source technologies. 
- Fostering meaningful new professional connections and friendships across different disciplines in virtual venues [where people would not otherwise meet in the halls of the departments or R&D labs of their corporations]; the general goal of AI-assisted PKM and PKE is to accelerate the continuous learning and development processes, to spark new creative work, and, most importantly, to meet new friends by sharing this journey of building PKE technology to accelerate the continuous learning process in public 
- As we learn more, we will attempt to better transform atomic notes, likely collected in simple MarkDown files used for this **mdBook** knowledgebase, from a static archive or just an online *book* into a more dynamic, programmable publishing AI engine, ready for sharing, collaboration, querying and other advanced augmentation with AI extensiions ... but in order to do this, we must articulating and embody the goals and principles of a systematic PKE framework to accelerate our own autodidactic education ... which is key in understanding the details of research in new systems at the forefront of technological innovation in various disciplines.


## Core principles

- **There's always going to be someone, somewhere who developing a better feature** ... not necessarily a better system, but a compelling feature to understand and appraise. We want to be aware of what's happening with shiny new features, but we want to understand whether or not they represent generally better system. The [Rust programming language](https://doc.rust-lang.org/book/)'s core feature, for example, is in its ownership and borrowing system, enforced by the RustLang borrow checker at compile time resulting in greater safety and simplicity in code, while retaining the speed of C language. The Modular Platform, with Mojo, Max, and the MLIR compiler framework, offers a different approach, particularly focused on high-performance AI development and leveraging advancements in compiler technology. [Mojo, inspired by Rust](https://www.modular.com/blog/mojo-vs-rust) and built on a next-generation MLIR compiler framework, aims to provide even higher levels of performance, particularly for AI applications, outperforming Rust in certain scenarios, like DNA parsing, through features like [eager destruction](https://users.rust-lang.org/t/emulating-eagerly-dropping-of-values/103171), efficient [Single Instruction, Multiple Data](https://en.wikipedia.org/wiki/Single_instruction,_multiple_data) (SIMD) ergonomics, and advanced compiler optimizations. *We love the RustLang system and developer ecosystem, ie RustLang is why this book uses [mdBook](https://rust-lang.github.io/mdBook/) ... but over time, we might find that we like Mojo and the Modular platform even more.*
- The **extensibility of open source enables its key feature, the strengthening and deepening of the interaction in the development community** surrounding an open source project. One learns most, best, fastest by attempting to teach others and trying to understand their learning process. People will fail to understand, fail to adopt, fail to use because the technology is inheritly failure prone, but our intention must be to learn from failure -- in fact, the principle must be to ***fail fast, in order to learn faster.*** Everything in this curriculum is an experiment intended push envelopes in order to court failure. 
- [**Dogfooding new technology](https://en.wikipedia.org/wiki/Eating_your_own_dog_food) is the best way to learn how to develop new technology** and to meet people who are also serious about this objective.
- This **100-day plan adopts a ***documenation-first*** direct-to-book methodology**, which means that instead of developing a better private note-taking app [because so many others are doing that](./nested/001_2.md), our focus is on this 100-day plan as the central artifact presented as a living, version-controlled technical book, built with [**mdBook**.](https://medium.com/@airabbitX/my-journey-with-gitbook-and-mdbook-navigating-documentation-tools-5d653f76d58f). [mdBook's key selling point](https://rust-lang.github.io/mdBook/) is its speed, safety, and simplicity, its integrated search support and focus on atomic Markdown-based, locally controlled documentation, particularly for technical projects and for getting involved int the [Rust programming language](https://doc.rust-lang.org/book/) and it [growing developer ecosystem](https://medium.com/@datajournal/is-rust-still-surging-in-2025-49bfc6d1ce5d). 
- We are attempting to build something cyclonic, which means that it's ok to spin it up slow somewhere in the hinterlands in total isolation, but **maintaining rotational inertia has to matter, ie the PKE system has to be built to feed back useful knowledge to help PKE developers dev the PKE system** ... at first, we get the flywheel moving, then maybe try to spin the flywheel a little faster ... but even when we struggle, we stay at it and keep the flywheel spinning every day.
- **Reuse, adapt, polish, master FIRST, rather than inventing your own.** Instead of rolling our own that's just so or spending money on something with extra features, we will rely upon the GitHub **Discussion** and **Issue** and **Project** functionality, fully exploiting GitHub's ongoing GitHub Projects [along with Discussions and Issues] because these things are sufficient and an adaptable collection of pages, presenting your data, which you can view as a table, a kanban board, or a roadmap and that stays up-to-date with GitHub data. Your GitHub projects can track issues, pull requests, and ideas that you note down AND ... they can, of course, be linked to our own .md pages ... AND anybody else in the world that finds our material useful also has full access to everything GitHub puts out there.

## Success Metrics

- At first, it's simple -- just a matter about completing today's module, while looking forward 10-20 days ahead to see how the work in this Phase sets up the next Phase ... then completing the Phase, looking at full horizon of all 100-days ahead ... thus, generally, not just looking ahead, but updating and revising the 100-module strategic curriculum, and maybe going back and correcting what should have been included in earlier modules ... with a long-term view, informed by the daily experience of showing up, rather than on temporary impatience or whim ... in other words, success of PKE system is not exactly just about how it helps only one highly experienced multi-disciplinary systems engineer, although that's enough ... hopefully, the process will help engineering new opportunities to dogfood something of greater value for others.

- The primary focus is on this PKE development journey of being much more seriously intentional about the technology of autodidactic learning and  dogfooding the technology in order to continually learn better ways to learn and **meet new colleagues who share that desire to accelerate learning**. The whole point of open source PKE technologies assembled and developed during this journey serving goes beyond the enabling toolkit, but actually uses the process of dogfooding the PKE as well as a means of meeting more colleagues and making new friendships with people who enjoy the journey of continual learning.

- Whether one is successful in the development of PKE technology will be tough to measure until after the PKE technology has been used, adopted, improved. Success along the way is a matter of just showing up every day to keep the flywheel spinning. The rotational inertia of developing the PKE technology necessarily must be transitted through the larger roadmap and staying focused on that larger picture [which will change as the PKE technology is built]. 


### **The 100-Day Personal Knowledge Engineering Curriculum Overview**

| Phase | Module Range | Core Objective | Key Deliverables |
| :---- | :---- | :---- | :---- |
| [**Phase 1: Foundation & Systems Architecture**](1.md) | Modules 1-20 | To design and build the core infrastructure of the PKES around a publication-first, mdBook-centric workflow. | A fully configured mdBook project serving as a "personal library"; automated content pipelines; a public-facing professional identity hub. |
| [**Phase 2: Horizon Scanning & Deep Learning**](2.md) | Modules 21-50 | To systematically identify, compare, and learn emerging technologies relevant to personal and professional goals through hands-on, failure-tolerant projects documented as book chapters. | An automated tech-trend dashboard; deep-dive projects in selected domains (e.g., Generative AI, Neuromorphic Computing); refreshed mathematical foundations. |
| [**Phase 3: Creation & Contribution**](3.md) | Modules 51-80 | To translate learned knowledge into tangible public artifacts and contribute to the open-source community, using creation as a vehicle for connection. | Multiple open-source project contributions; a portfolio of projects on GitHub; published models on Hugging Face; a series of technical tutorials published in the book. |
| [**Phase 4: Connection & Synthesis**](4.md) | Modules 81-100 | To leverage the published book and other artifacts for networking, establish thought leadership, and synthesize career experience into high-value knowledge products that foster community. | A targeted networking strategy; a personal CRM built as an mdBook extension; a plan for an online tech discussion group; tools for tracking professional opportunities. |

## **Conclusion**

This 100-module curriculum provides a rigorous and systematic pathway for an experienced engineer to build a Personal Knowledge Engineering System centered on the principles of autodidacticism and community. By progressing through the four phases—Foundation, Learning, Creation, and Connection—the engineer will not only acquire skills in the most important modern technologies but will also construct a sustainable, integrated system for continuous professional growth and friendship. The emphasis on rapid, failure-tolerant experimentation, open-source contribution, and value-driven networking is designed to combat the sense of being overwhelmed by providing a clear, actionable framework. The final deliverable is more than a collection of notes and projects; it is a fully operational flywheel that transforms a lifetime of experience into a source of ongoing learning, discoverability, and meaningful connection within the global technology community.


## Appendix:  Personal Knowledge Management (PKM) Ideas To Be Built Upon As This Personal Knowledge Engineering SYSTEM Is Developed

1. **Foam**: VSCode-powered personal knowledge management and sharing system in the form of a VSCode extension for developers, the [Foam](https://github.com/foambubble/foam) system is inspired by [Roam Research](https://roamresearch.com/) reduces context-switching for devs who are already using [Visual Studio Code](https://code.visualstudio.com/) and [GitHub](https://github.com/), making it easier to build personal MarkDown wikis [and things like mdBooks] alongside code, enhancing efficiency in tech-heavy careers.

2. **[Roam Research](https://roamresearch.com/)**: Pioneering block-level references and daily notes, the [Roam writing tool](https://roamresearch.com/#/app/help/page/dZ72V0Ig6) enables fluid, non-hierarchical knowledge structures that mirror the interconnected nature of software development workflows. For engineers, its transclusion feature turns scattered thoughts into reusable components, much like modular code, accelerating problem-solving in fast-paced tech teams.

3. **Logseq**: As a local-first, privacy-focused tool with Git integration, Logseq appeals to developers by applying version control principles to personal notes. Its outliner format and query capabilities make it outstanding for managing technical documentation, ensuring knowledge remains accessible and evolvable in startup settings without cloud dependencies.

4. **RemNote**: Integrating spaced repetition into note-taking, RemNote automates flashcard creation from technical notes, perfect for mastering programming languages or frameworks. This fusion of learning and documentation makes it worthy of emulation for career growth, as it builds long-term retention of complex tech concepts essential for interviews and innovation.

5. **Notion Databases for PKM**: Transforming notes into relational databases, Notion allows dynamic views and filters for organizing project roadmaps and tech stacks. Its versatility in creating custom workflows without coding empowers startup founders to centralize knowledge, reducing context-switching and boosting team productivity.

6. **Digital GTD Implementations**: Using tools like Todoist with Notion, this adapts Getting Things Done for digital age, adding automation to task capture. For tech careers, it stands out by linking actions to knowledge artifacts, ensuring ideas turn into executable projects without falling through cracks.

7. **GTD + Zettelkasten Hybrids**: Combining task management with knowledge linking, hybrids like Obsidian with plugins bridge execution and ideation. This is exemplary for engineers, as it captures expertise during projects, creating reusable assets that compound over a career in evolving tech landscapes.

8. **OmniFocus Advanced Perspectives**: Customizable task views surface context-specific actions, revolutionizing how developers manage multiple roles. Its query system emulates database thinking, making it invaluable for startups where quick reconfiguration of focus areas drives agility and success.

9. **Andy Matuschak's Evergreen Notes**: Emphasizing atomic, declarative notes written for future self, this methodology builds timeless knowledge bases. In tech, it's outstanding for documenting evolving systems, ensuring notes remain valuable across projects and career stages.

10. **Digital Gardens**: Treating knowledge as cultivated spaces with maturity stages, tools like Obsidian publish thinking in progress. For startups, this normalizes public learning, fostering community feedback that accelerates product development and personal growth.

11. **Obsidian Zettelkasten**: This digital adaptation of Luhmann's slip-box system excels in bidirectional linking and graph visualization, making it ideal for tech professionals to uncover hidden connections in code notes and project ideas. Its plugin ecosystem allows seamless integration with Git for version-controlled knowledge bases, fostering innovation in startup environments where rapid idea iteration is crucial.

12. **Dendron**: Hierarchical notes with schema validation bring type safety to knowledge organization. This prevents drift in large tech knowledge bases, making it essential for maintaining structured documentation in scaling startups.

13. **TiddlyWiki**: Single-file wikis offer portable, serverless knowledge bases. For mobile tech workers, its self-contained nature ensures access anywhere, supporting uninterrupted ideation and reference in dynamic startup environments.

14. **Zotero**: Beyond citations, it scrapes web content and annotates PDFs for research. Tech professionals emulate it for curating API docs and papers, integrating literature review into development workflows.

15. **Mendeley**: Adding social networking to references, it discovers work through connections. In tech communities, this social filtering uncovers relevant tools and papers, expanding professional networks and knowledge.

16. **EndNote**: Automated formatting across styles saves time on technical writing. For engineers documenting inventions, it streamlines publication, freeing focus for innovation.

17. **ReadCube Papers**: Visual PDF management with enhanced reading features centralizes research consumption. This innovation suits tech careers by prioritizing PDF-based learning, common in specs and whitepapers.

18. **Citavi**: Combining references with planning, it supports full research workflows. Worthy for tech project managers integrating sources with tasks, ensuring evidence-based decisions.

19. **JabRef**: Open-source BibTeX management for LaTeX users. Its deep integration aids engineers in academic-tech crossover, maintaining open bibliographic data.

20. **RefWorks**: Cloud-based for accessible collaboration. Pioneering web access, it enables team knowledge sharing in distributed startups.

21. **Darwin's Transmutation Notebooks**: Systematic cross-referencing of observations built evolutionary theory. Emulate for tech by indexing experiments across projects, synthesizing long-term insights.

22. **Einstein's Thought Experiment Documentation**: Recording imaginative scenarios alongside math. For developers, this documents creative problem-solving, preserving paths to breakthroughs.

23. **Einstein's Zurich Notebook**: Documenting failures and successes. In startups, this complete record aids debugging and iteration, learning from all attempts.

24. **Leonardo da Vinci's Multi-Topic Integration**: Visual-textual fusion in notebooks. Tech emulation uses diagrams as primary carriers, enhancing system design communication.

25. **Marie Curie's Laboratory Documentation**: Meticulous recording including negatives. For engineers, this comprehensive history enables pattern detection in trials.

26. **Edison's Invention Factory System**: Witnessed notebooks for IP protection. Startups benefit from searchable solution archives, securing and reusing inventions.

27. **Newton's Mathematical Notebooks**: Developing notation with discoveries. Worthy for creating personal symbols to tackle complex tech problems.

28. **Galileo's Observation Logs**: Quantitative measurements with drawings. Establishes precision in tech observations, foundational for data-driven decisions.

29. **Kepler's Calculation Notebooks**: Preserving iterative refinements. Documents discovery processes, essential for refining algorithms in tech.

30. **Faraday's Laboratory Notebooks**: Continuous numbering for cross-referencing. Creates searchable archives, ideal for long-term tech research.

31. **Pasteur's Laboratory Protocols**: Standardized controls. Ensures reproducibility, critical for software testing and validation.

32. **Mendel's Statistical Record-Keeping**: Quantitative biology analysis. Applies stats to tech metrics, founding data-informed practices.

33. **Linnaeus's Species Classification System**: Hierarchical taxonomies. Organizes tech stacks hierarchically, accommodating new tools.

34. **Humboldt's Integrated Field Studies**: Multidisciplinary connections. Pioneers holistic views, useful for interdisciplinary tech projects.

35. **Hooke's Micrographia Methods**: Illustration as scientific tool. Revolutionizes visual documentation in UI/UX design.

36. **Brahe's Astronomical Data Tables**: Unprecedented accuracy. Emphasizes precision in tech data logging.

37. **Vesalius's Anatomical Documentation**: Observation over authority. Corrects assumptions in system architectures.

38. **Grinnell System**: Tiered field documentation. Separates observations from analysis, structuring tech logs.

39. **Standard Laboratory Notebook Practices**: Bound, witnessed pages for IP. Legally defensible, crucial for startup patents.

40. **Electronic Laboratory Notebooks (ELNs)**: Digital compliance with instrument integration. Speeds development, reducing errors in tech labs.

41. **CAD File Management Systems**: Version control for designs. Enables parallel engineering, avoiding bottlenecks.

42. **Product Data Management (PDM) Systems**: Centralizes product info. Integrates departments, reducing errors in startups.

43. **Six Sigma DMAIC Documentation**: Statistical validation. Data-driven improvements, quantifiable for tech processes.

44. **Failure Mode and Effects Analysis (FMEA)**: Proactive failure documentation. Prevents catastrophes in software engineering.

45. **Systems Engineering Management Plans (SEMP)**: Technical performance tracking. Manages complex tech developments.

46. **Requirements Traceability Matrices (RTM)**: Linking needs to implementation. Ensures complete coverage in projects.

47. **Quality Management System (QMS) Documentation**: ISO compliance. Standardizes quality in tech firms.

48. **Document Control Systems**: Revision management. Prevents errors from outdated specs.

49. **Change Management Documentation**: Impact analysis. Avoids cascading failures in code changes.

50. **Technical Data Packages (TDP)**: Complete manufacturing definitions. Enables outsourcing in tech production.

51. **Lean Documentation Principles**: Minimize non-value docs. Reduces burden while maintaining quality.

52. **Agile Engineering Documentation**: Iterative refinement. Matches docs to evolving products.

53. **Model-Based Systems Engineering (MBSE)**: Models as truth sources. Eliminates inconsistencies.

54. **Digital Thread Documentation**: Lifecycle connectivity. Enables predictive maintenance.

55. **Configuration Management Databases (CMDB)**: Track interdependencies. Predicts change impacts.

56. **Root Cause Analysis (RCA) Documentation**: Evidence-based investigations. Prevents recurrence in bugs.

57. **Jupyter Notebooks**: Executable code with narratives. Democratizes data science, accessible for tech learning.

58. **Observable Notebooks**: Reactive computational docs. Creates interactive explanations for complex algorithms.

59. **Marimo Notebooks**: Deterministic execution. Ensures reproducibility in ML experiments.

60. **Google Colab**: Free GPU access. Democratizes deep learning for startup prototyping.

61. **Pluto.jl**: Reactive Julia notebooks. Guarantees reproducibility in scientific computing.

62. **Literate Programming**: Documentation primary, code extracted. Enhances understanding in open-source contributions.

63. **Documentation-Driven Development (DDD)**: Docs before code. Catches API issues early.

64. **README-Driven Development**: User docs first. Ensures usability in tech products.

65. **Software Architecture Decision Records (ADRs)**: Capture decisions with context. Preserves memory for team handovers.

66. **Design Docs**: Standardize communication. Creates searchable decision archives.

67. **Request for Comments (RFC) Process**: Collaborative design. Opens review, catching problems early.

68. **DevOps Runbooks**: Operational procedures. Codifies knowledge for reliable responses.

69. **Post-Mortem Documentation**: Blameless failure analysis. Improves systems psychologically safely.

70. **Site Reliability Engineering (SRE) Documentation**: Quantified objectives. Makes reliability engineering concern.

71. **Code Review Comments as Documentation**: Preserve discussions. Archives engineering rationale.

72. **Pull Request Templates**: Standardize changes. Improves knowledge transfer.

73. **Commit Message Conventions**: Machine-readable history. Automates changelogs.

74. **Learning-in-Public Methodologies**: Share journeys. Accelerates skills through feedback.

75. **Technical Blogging Platforms**: Community engagement. Motivates documentation.

76. **Today I Learned (TIL) Repositories**: Micro-insights. Accumulates knowledge effortlessly.

77. **Static Site Generators for Documentation**: Markdown to sites. Focuses on content.

78. **API Documentation Generators**: From annotations. Syncs docs with code.

79. **Interactive Documentation**: Embedded playgrounds. Improves learning outcomes.

80. **Knowledge Bases as Code**: Version control for docs. Ensures quality through pipelines.

81. **Tana**: Supertags and AI for system-based organization. Powers advanced PKM with reusable metadata for tech workflows.

82. **Reflect Notes**: Networked thought with tasks. Balances traditional and PKM, integrating daily notes seamlessly.

83. **Heptabase**: Visual canvases for ideas. Suits visual thinkers in tech, blending PKM with project management.

84. **AFFiNE**: Universal editor for notes and tasks. Affordable, feature-rich for boosting productivity in startups.

85. **Capacities**: Notes, projects, visualizations. Meets knowledge workers' needs with seamless integrations.

86. **Evernote**: Advanced search for notes. Classic reliability for capturing ideas in busy tech careers.

87. **Microsoft OneNote**: Microsoft ecosystem integration. Seamless for enterprise tech stacks.

88. **Craft**: Sleek collaborative design. Ideal for creatives in tech product teams.

89. **Zettlr**: Citation management for research. Supports academic-tech writing.

90. **Milanote**: Visual organization. Brainstorming boards for startup ideation.

91. **Antinet Zettelkasten**: Analog-first revival. Forces deep processing, countering digital overload.

92. **Smart Notes Method**: Thinking tool focus. Drives output from notes, essential for content creation in tech.

93. **Memex Methodology**: Associative trails. Inspires modern linked bases for knowledge retrieval.

94. **Linking Your Thinking**: Emergent maps. Organic structure for flexible tech knowledge.

95. **Garden-Stream Dichotomy**: Separate capture and curation. Reduces guilt, streamlines workflows.

96. **Resonance Calendar**: Emotion-driven tracking. Compiles insights for reflective career growth.

97. **Quadrant Note-Taking**: Structured analysis. Forces context, reducing storage issues.

98. **Notion + Zapier + Google Drive**: Automated knowledge hub. Centralizes startup ops, enhancing efficiency.

99. **Obsidian + Git Integration**: Version-controlled notes. Applies dev practices to PKM, ensuring durability.

100. **Logseq + Whiteboards**: Connected outlining with visuals. Powers brainstorming and knowledge linking for innovative tech careers.

